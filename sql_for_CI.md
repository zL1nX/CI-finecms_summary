#sql注入在CI框架中的情况
- 版本情况:2.2.6 & 3.1.5
- 参考文章:[csdn][]
[csdn]:http://blog.csdn.net/u011721501/article/details/44787963
- 最终结果:似乎是失败了

#实验过程
##version：2.2.6
- 阅读文章后发现文章所提的CI框架只对XSS进行防御而没有对SQL进行应有的措施对现有的版本而言是不正确的，因为版本的原因，新版的CI已经能做到对sql中常见字符如'等进行过滤，因此接下来的的任务主要就是按照文章测试其他情况是否可以实现
- 文章中说如果一个数组的键名进行了恶意伪造，即添加了一些恶意字符，对于CI中的`escape_str`函数是不会对键名进行过滤的。这里我们向一个页面post了一个参数数组`info`，发现CI立即告诉我们一个错误信息*disallowed key characters*,
  说明CI已经替我们将不合法字符检测到了，这里的外部sql注入似乎是不可行的（对于其他特殊字符，基本都测试过，均被检测出来）
- 文章中提到这里是否能检测出来与CI中post，get方法里的true参数有关，然而对这个版本的CI来说，不论是否加true，都会有相同的不合法显示。这里基本可以说明对于这个版本的CI，sql注入是不可行的。

> 这里其实也不能完全断绝sql注入，原因在末尾会提到

##version : 3.1.5
- 实验方法与上面类似，不同的是在发现这个版本的CI居然对sql的特殊字符真的没有报警，这里本以为是新版的一个疏忽，然而其实这是新版对于用户体验的一个提升。
- 在外部进行post参数info时，键名里的如果含特殊字符，CI则会显示NULL的字样，这说明对于文章中的注入手法还是被检测到了。
- 基本结果与上面类似，至于上面提到的不能完全杜绝sql是因为，有的开发者在使用CI中的接受参数，数据库调用时，还是习惯用原生php去写，数据库调用也是用原生的sql去操作等，这样一来，还是会给SQL注入
  以可乘之机，不过这就与CI无关，是与人的不规范操作有关

###综上所述，包括以后版本的CI框架，在程序层面上已经防御了SQL注入，但是在审计时要注意是否使用了原生php书写，这是可能引发sql的原因。